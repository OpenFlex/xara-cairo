/*
 * xara-cairo, a vector drawing program
 *
 * Based on Xara XL, Copyright (C) 1993-2006 Xara Group Ltd.
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation, either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 */


#ifndef NODECNTR_H
#define NODECNTR_H

//#include "becomea.h" - in camtypes.h [AUTOMATICALLY REMOVED]
//#include "biasgain.h" - in camtypes.h [AUTOMATICALLY REMOVED]

class ExtendParams;
class NodeContourController;
class AttrBrushType;
class SumAllPathsElem;
class NodeCompound;

/***********************************************************************************************

>	class NodeContour : public NodeRenderableInk

	Author:		David_McClarnon (Xara Group Ltd) <camelotdev@xara.com>
	Created:	12/8/99
	Purpose:	Contour node

***********************************************************************************************/

class NodeContour : public NodeRenderableInk
{
	// Give my name out in memory dumps
	CC_DECLARE_DYNCREATE(NodeContour);

public:
	NodeContour();

	NodeContour(Node* ContextNode,  
				AttachNodeDirection Direction,  
				BOOL Locked = FALSE, 
				BOOL Mangled = FALSE,  
				BOOL Marked = FALSE, 
				BOOL Selected = FALSE    
				) ;

	~NodeContour();

	// Copy functions
	virtual Node* SimpleCopy(); 
	void CopyNodeContents(NodeContour* pNewNode);
	virtual void PolyCopyNodeContents(NodeRenderable* pNodeCopy);

	// get the bounding rect of me
	virtual DocRect GetBoundingRect(BOOL DontUseAttrs = FALSE, BOOL HitTest = FALSE);
	virtual DocRect GetBlobBoundingRect();

	virtual void RenderTinyBlobs(RenderRegion * pRegion);

	virtual void Render(RenderRegion* pRender);

	virtual BOOL DoBecomeA(BecomeA* pBecomeA);
	virtual BOOL CanBecomeA(BecomeA* pBecomeA); 

	virtual BOOL NeedsParent(Node* pClassNode) const;
	virtual NodeCompound* GetParentController() const;

	virtual String Describe(BOOL Plural, BOOL Verbose); 

	virtual BOOL IsAContour() const { return TRUE;}
	BOOL GenerateContour(List * pList = NULL, CCAttrMap * pAttrMap = NULL);
	
	void DeleteCache();

	void Transform(TransformBase &Trans);

	void RenderEorDrag(RenderRegion * pRender);

	// Version 2 file format functions
	virtual BOOL WritePreChildrenWeb(BaseCamelotFilter* pFilter);
	virtual BOOL WritePreChildrenNative(BaseCamelotFilter* pFilter);

	virtual BOOL AllowOp(ObjChangeParam *pParam, BOOL SetOpPermissionState = TRUE,
												 BOOL DoPreTriggerEdit = TRUE);

	// Karim MacDonald 25/11/1999
	// virtual Extend functions; see declaration/implementation in Node.
public:
	virtual BOOL IsTypeExtendible() const { return TRUE; }
	virtual DocRect ValidateExtend(const ExtendParams& ExtParams);
	virtual void Extend(const ExtendParams& ExtParams);

	// smooths the path
	static BOOL SmoothPath(Path * pPath);

	virtual BOOL OnNodePopUp(Spread* pSpread, DocCoord PointerPos, ContextMenu* pMenu);

	static BOOL GenerateContourPathForNode(	Path* pDestPath,
											Node* pSourceNode,
											const List* pSourceList,
											const MILLIPOINT nWidth,
											const BOOL fOuterContour	= TRUE,
											const JointType jt			= RoundJoin,
											const MILLIPOINT nFlatness	= -1,
											const BOOL fUseLineWidths	= TRUE,
											const BOOL fIncludeShadows	= FALSE	);

	virtual INT32 EstimateNodeComplexity (OpParam* details);

protected:
	// blend attributes function
	BOOL BlendAttributes(RenderRegion * pRender, CCAttrMap * pAttrMapStart, 
						 CCAttrMap * pEndAttrMap, CCAttrMap * pBlendedAttrMap, 
						 double BlendRatio);

	// copies all the attributes in the attribute map onto the node
	BOOL CopyAttributes(NodeRenderableInk * pNode, CCAttrMap * pAttrMap);

	// smooths all paths
	BOOL SmoothPaths();

	// finds the node I'm to use to blend colours from
	NodeRenderableInk * FindNodeToContour(NodeRenderableInk * pInk);

protected:
	// the source path generated by the path processor
	Path m_SourcePath;

	// the path list generated by the contour
	Path * m_pPathList;
	INT32 m_NumPaths;

	BOOL m_FirstRender;

} ;

/***********************************************************************************************

>	class ContourBecomeA: public BecomeA

	Author:		David_McClarnon (Xara Group Ltd) <camelotdev@xara.com> Mc
	Created:	18/10/94
	Purpose:	This is used to turn all nodes which are to be contoured into a single path

***********************************************************************************************/

class ContourBecomeA : public BecomeA
{
public:
	ContourBecomeA(	BecomeAReason Reason,
					CCRuntimeClass* pClass, 
					UndoableOperation* pOp, 
					BOOL Sel,
					Path * pPathList,
					Path * pSummedPath, 
					INT32 Width,
					INT32 NumSteps,
					BOOL bOuter,
					CProfileBiasGain &Profile,
					JointType jt = RoundJoin,
					double Flatness = 200.0,
					BOOL bIncludeLineWidths = TRUE) : BecomeA(Reason, pClass, pOp, Sel)
	{
		m_pPathList = pPathList;
		m_bNodeIsPath = FALSE;
		m_Width = Width;
		m_NumSteps = NumSteps;
		m_pSummedPath = pSummedPath;
		m_bOuter = bOuter;
		m_Profile = Profile;
		m_Join	  = jt;
		m_Flatness = Flatness;
		m_bIncludeLineWidths = bIncludeLineWidths;

		// we're only interested in the silhouettes of shapes.
		fSilhouette = TRUE;

		m_bContourBrush = FALSE;
	}

	// this sets the variable which tells the passback function that the next node
	// passed in is a path node
	void SetNodeIsPath(BOOL b) { m_bNodeIsPath = b; }
	
	// This function should be called when Reason == BECOMEA_PASSBACK 
	virtual BOOL PassBack(NodeRenderableInk* pNewNode,NodeRenderableInk* pCreatedByNode,CCAttrMap* pAttrMap);

	// MRH New Gavin Version!
	BOOL GenerateContourPaths(Path* pPathToContour, Path* pPathList, JointType jt, bool Outer = true,
							  bool UseContourMode = true, LineCapType ct = LineCapRound);
	
	void SetContourBrush(BOOL Set);
protected:
	// DY we want to contour nodes with brushes applied to them, so heres a yucky special case function
	BOOL PassbackBrush(NodeRenderableInk* pCreatedByNode, NodeRenderableInk** ppNewNode);

private:
	Path * m_pPathList;
	
	// the summed path of all nodes' paths which have been passed through the passback mecahnism
	Path * m_pSummedPath;
	INT32 m_NumSteps;
	INT32 m_Width;
	BOOL m_bNodeIsPath;
	BOOL m_bOuter;
	BOOL m_bIncludeLineWidths;

	CProfileBiasGain m_Profile;

	JointType m_Join;

	double m_Flatness;

	BOOL m_bContourBrush;

};

#endif // NODECNTR_H



	


